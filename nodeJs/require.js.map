{"version":3,"file":"require.js","sources":["../nodeTs/FFHandle/FFHandleDataToFile.ts","../nodeTs/FFHandle/FFHandleDeleteFile.ts","../nodeTs/FFHandle/FFHandleDeleteFolder.ts","../nodeTs/FFHandle/FFHandleFileParse.ts","../nodeTs/FFHandle/FFHandleGetStats.ts","../nodeTs/FFHandle/FFHandleIsExists.ts","../nodeTs/FFHandle/FFHandleIsFile.ts","../nodeTs/FFHandle/FFHandleIsFolder.ts","../nodeTs/FFHandle/FFHandleReadDownFile.ts","../nodeTs/FFHandle/FFHandleRename.ts"],"sourcesContent":["import fs from 'fs'\n\n/**\n * @description 将数据保存成文件\n * @param {*} fData 文件数据\n * @param {string} fFile 文件路径\n * @returns {Promise<String>}\n */\nexport const FFHandleDataSaveFile = (fData: any, fFile: string): Promise<string> => {\n  return new Promise((resolve, reject) => {\n    fs.writeFile(fFile, fData, (err) => {\n      err ? reject('') : resolve(fFile)\n    })\n  })\n}\n","import fs from 'fs'\n\n/**\n * @description 删除文件\n * @param {string} fFile 文件路径\n * @returns {Promise<Boolean>}\n */\nexport const FFHandleDeleteFile = (fFile: string): Promise<boolean> => {\n  return new Promise((resolve, reject) => {\n    if (fFile) {\n      if (fs.existsSync(fFile)) {\n        fs.unlink(fFile, (err) => {\n          err ? reject(false) : resolve(true)\n        })\n      } else {\n        resolve(true)\n      }\n    }\n  })\n}\n","import fs from 'fs'\n\n/**\n * @description 删除文件夹\n * @param {string} fFolder 文件夹路径\n * @returns {Promise<Boolean>}\n */\nexport const FFHandleDeleteFolder = (fFolder: string): Promise<boolean> => {\n  return new Promise((resolve, reject) => {\n    if (fs.existsSync(fFolder)) {\n      fs.rmdir(fFolder, {recursive: true}, (err) => {\n          err ? reject(false) : resolve(true)\n        }\n      )\n    } else {\n      resolve(true)\n    }\n  })\n}\n","import fs from 'fs'\n\nexport class FFHandleFileParse {\n  // 定义变量\n  private suffix!: string;\n  private path!: string;\n  private filePath!: string;\n  private newFile!: string;\n  private originalName!: string;\n\n  // 预先处理\n  constructor(aFile: any) {\n    this.parseFile(aFile)\n  }\n\n  // 解析文件\n  parseFile(file: Record<string | number | symbol, any>) {\n    // noinspection SpellCheckingInspection\n    const {destination: des, filename = '', originalname: originalName, path = ''} = file\n    const suffix = originalName.split('.')[1] || ''\n    this.suffix = suffix\n    this.path = path\n    this.filePath = `${des}${filename}.${suffix}`\n    this.newFile = `${filename}.${suffix}`\n    this.originalName = originalName\n  }\n\n  // 解析\n  parse() {\n    return new Promise(async (resolve, reject) => {\n      if (this.suffix) {\n        if (fs.existsSync(this.path) && !fs.existsSync(this.filePath)) {\n          fs.renameSync(this.path, this.filePath)\n        }\n        resolve(this)\n      } else {\n        reject(new Error('上文件的后缀名无效'))\n      }\n    })\n  }\n}\n","import fs from 'fs'\n\n/**\n * @description 获取目录或文件的系统明细\n * @param {string} fOrFPath 文件（夹）路径\n * @returns {Promise<Record<string | number | symbol, any>>}\n */\nexport const FFHandleGetStats = (fOrFPath: string): Promise<Record<string | number | symbol, any>> => {\n  return new Promise((resolve, reject) => {\n    fs.stat(fOrFPath, (err, stats) => {\n      err ? reject({}) : resolve(stats)\n    })\n  })\n}\n","import fs from \"fs\";\n\n/**\n * @description 文件或文件夹是否存在\n * @param fOrFPath 文件（夹）路径\n * @returns {Promise<Boolean>}\n */\nexport const FFHandleIsExists = (fOrFPath: string): Promise<boolean> => {\n  return new Promise((resolve, reject) => {\n    const result = fs.existsSync(fOrFPath)\n    result ? resolve(true) : reject(false)\n  })\n}\n","import fs from 'fs'\n\n/**\n * @description 是否文件\n * @param {String} fFile 文件路径\n * @returns {Promise<Boolean>}\n */\nexport const FFHandleIsFile = (fFile: string): Promise<boolean> => {\n  return new Promise((resolve, reject) => {\n    fs.stat(fFile, (err, stats) => {\n      err ? reject(false) : stats.isFile() ? resolve(true) : reject(false)\n    })\n  })\n}\n","import fs from 'fs'\n\n/**\n * @description 是否文件夹\n * @param {String} fFolder 文件夹路径\n * @return {Promise<Boolean>}\n */\nexport const FFHandleIsFolder = (fFolder: string): Promise<boolean> => {\n  return new Promise((resolve, reject) => {\n    fs.stat(fFolder, (err, stats) => {\n      err ? reject(false) : stats.isDirectory() ? resolve(true) : reject(false)\n    })\n  })\n}\n","import fs from 'fs'\n\n/**\n * @description 目录下所有的文件(不包含文件夹)\n * @param {string} folder 文件夹路径\n * @returns {Promise<Array>}\n */\nexport const FFHandleReadDownFile = (folder: string): Promise<Array<any>> => {\n  return new Promise((resolve, reject) => {\n    fs.readdir(folder, (err, files) => {\n      err ? reject([]) : resolve(files)\n    })\n  })\n}\n","import fs from 'fs'\n\n/**\n * @description 重命名（移动）文件（夹）\n * @param {string} fOld 原文件（夹）路径\n * @param {string} fNew 新文件（夹）路径\n * @return {Promise<Boolean>}\n */\nexport const FFHandleRename = (fOld: string, fNew: string): Promise<boolean> => {\n  return new Promise((resolve, reject) => {\n    fs.rename(fOld, fNew, (err) => {\n      err ? reject(false) : resolve(true)\n    })\n  })\n}\n"],"names":["fData","fFile","Promise","resolve","reject","fs","writeFile","err","existsSync","unlink","fFolder","rmdir","recursive","constructor","aFile","this","parseFile","file","destination","des","filename","originalname","originalName","path","suffix","split","filePath","newFile","parse","__awaiter","renameSync","Error","fOrFPath","stat","stats","isFile","isDirectory","folder","readdir","files","fOld","fNew","rename"],"mappings":";;;;;;;;;;;;;;;kUAQoC,CAACA,EAAYC,IACxC,IAAIC,SAAQ,CAACC,EAASC,KAC3BC,EAAAA,QAAGC,UAAUL,EAAOD,GAAQO,IAC1BA,EAAMH,EAAO,IAAMD,EAAQF,oCCJEA,GAC1B,IAAIC,SAAQ,CAACC,EAASC,KACvBH,IACEI,EAAE,QAACG,WAAWP,GAChBI,EAAAA,QAAGI,OAAOR,GAAQM,IAChBA,EAAMH,GAAO,GAASD,GAAQ,MAGhCA,GAAQ,oCCRqBO,GAC5B,IAAIR,SAAQ,CAACC,EAASC,KACvBC,EAAE,QAACG,WAAWE,GAChBL,EAAE,QAACM,MAAMD,EAAS,CAACE,WAAW,IAAQL,IAClCA,EAAMH,GAAO,GAASD,GAAQ,MAIlCA,GAAQ,sCCJZU,YAAYC,GACVC,KAAKC,UAAUF,GAIjBE,UAAUC,GAER,MAAOC,YAAaC,EAAGC,SAAEA,EAAW,GAAIC,aAAcC,EAAYC,KAAEA,EAAO,IAAMN,EAC3EO,EAASF,EAAaG,MAAM,KAAK,IAAM,GAC7CV,KAAKS,OAASA,EACdT,KAAKQ,KAAOA,EACZR,KAAKW,SAAW,GAAGP,IAAMC,KAAYI,IACrCT,KAAKY,QAAU,GAAGP,KAAYI,IAC9BT,KAAKO,aAAeA,EAItBM,QACE,OAAO,IAAI1B,SAAQ,CAAOC,EAASC,IAAUyB,EAAAd,UAAA,OAAA,GAAA,YACvCA,KAAKS,QACHnB,EAAE,QAACG,WAAWO,KAAKQ,QAAUlB,EAAAA,QAAGG,WAAWO,KAAKW,WAClDrB,EAAE,QAACyB,WAAWf,KAAKQ,KAAMR,KAAKW,UAEhCvB,EAAQY,OAERX,EAAO,IAAI2B,MAAM,8CC7BQC,GACxB,IAAI9B,SAAQ,CAACC,EAASC,KAC3BC,EAAAA,QAAG4B,KAAKD,GAAU,CAACzB,EAAK2B,KACtB3B,EAAMH,EAAO,IAAMD,EAAQ+B,kCCHAF,GACxB,IAAI9B,SAAQ,CAACC,EAASC,KACZC,EAAAA,QAAGG,WAAWwB,GACpB7B,GAAQ,GAAQC,GAAO,6BCHLH,GACtB,IAAIC,SAAQ,CAACC,EAASC,KAC3BC,EAAAA,QAAG4B,KAAKhC,GAAO,CAACM,EAAK2B,KACnB3B,EAAMH,GAAO,GAAS8B,EAAMC,SAAWhC,GAAQ,GAAQC,GAAO,kCCHnCM,GACxB,IAAIR,SAAQ,CAACC,EAASC,KAC3BC,EAAAA,QAAG4B,KAAKvB,GAAS,CAACH,EAAK2B,KACrB3B,EAAMH,GAAO,GAAS8B,EAAME,cAAgBjC,GAAQ,GAAQC,GAAO,sCCHpCiC,GAC5B,IAAInC,SAAQ,CAACC,EAASC,KAC3BC,EAAAA,QAAGiC,QAAQD,GAAQ,CAAC9B,EAAKgC,KACvBhC,EAAMH,EAAO,IAAMD,EAAQoC,gCCFH,CAACC,EAAcC,IACpC,IAAIvC,SAAQ,CAACC,EAASC,KAC3BC,EAAAA,QAAGqC,OAAOF,EAAMC,GAAOlC,IACrBA,EAAMH,GAAO,GAASD,GAAQ"}