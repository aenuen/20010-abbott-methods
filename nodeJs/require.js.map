{"version":3,"file":"require.js","sources":["../src/ensure/ensureFootHave.ts","../nodeTs/FFHandle/FFHandleFileParse.ts","../nodeTs/FFHandle/FFHandleGetStats.ts","../nodeTs/FFHandle/FFHandleIsExists.ts","../nodeTs/FFHandle/FFHandleIsFolder.ts","../nodeTs/FFHandle/FFHandleMakeFolderOne.ts","../nodeTs/FFHandle/FFHandleDataSaveFile.ts","../nodeTs/FFHandle/FFHandleDeleteFile.ts","../nodeTs/FFHandle/FFHandleDeleteFileSync.ts","../nodeTs/FFHandle/FFHandleDeleteFolder.ts","../nodeTs/FFHandle/FFHandleIsFile.ts","../nodeTs/FFHandle/FFHandleMakeFolderPath.ts","../nodeTs/FFHandle/FFHandleReadFolderDF.ts","../nodeTs/FFHandle/FFHandleReadFolderDFSync.ts"],"sourcesContent":["/**\n * @desc 保证字符串尾部含有指定字符\n * @param {number|string} ensureString\n * @param {number|string} ensureAssign\n * @returns {number|string}\n */\nexport const ensureFootHave = (ensureString: number | string, ensureAssign: number | string): string => {\n  const theString = String(ensureString)\n  const theAssign = String(ensureAssign)\n  return theString.substr(-theString.length) === theAssign ? theString : theString + theAssign\n}\n","const fs = require('fs')\n\nexport class FFHandleFileParse {\n  // 预先处理\n  private suffix: string | undefined;\n  private path: string | undefined;\n  private filePath: string | undefined;\n  private newFile: string | undefined;\n  private originalname: string | undefined;\n\n  constructor(aFile: any) {\n    this.parseFile(aFile)\n  }\n\n  // 解析文件\n  parseFile(file: Record<string | number | symbol, any>) {\n    const {destination: des, filename = '', originalname = '', path = ''} = file\n    const suffix = originalname.split('.')[1] || ''\n    this.suffix = suffix\n    this.path = path\n    this.filePath = `${des}${filename}.${suffix}`\n    this.newFile = `${filename}.${suffix}`\n    this.originalname = <string>originalname\n  }\n\n  // 解析\n  parse() {\n    return new Promise((resolve, reject) => {\n      if (this.suffix) {\n        if (fs.existsSync(this.path) && !fs.existsSync(this.filePath)) {\n          fs.renameSync(this.path, this.filePath)\n        }\n        resolve(this)\n      } else {\n        reject(new Error('上文件的后缀名无效'))\n      }\n    })\n  }\n}\n","import fs from 'fs'\n\n/**\n * @description 获取目录或文件的系统明细\n * @param {String} fOrFPath 要查看的目录或文件路径\n * @constructor\n */\nexport const FFHandleGetStats = (fOrFPath: string):Record<string | number | symbol, any> => {\n  return new Promise(resolve => fs.stat(\n    fOrFPath,\n    (err, stats) => {\n      err ? resolve({}) : resolve(stats)\n    })\n  )\n}\n","import fs from \"fs\";\n\n/**\n * @description 文件或文件夹是否存在\n * @param {string} fOrFPath\n * @constructor\n */\nexport const FFHandleIsExists=(fOrFPath:string) => {\n  return new Promise((resolve) => {\n    const boolean = fs.existsSync(fOrFPath)\n    resolve(boolean)\n  })\n}\n","import fs from 'fs'\n\n/**\n * @description 获取目录或文件的系统明细\n * @param {String} fOrFPath 要查看的目录或文件路径\n * @constructor\n */\nexport const FFHandleIsFolder = (fOrFPath: string) => {\n  return new Promise(resolve => fs.stat(\n    fOrFPath,\n    (err, stats) => {\n      err ? resolve(false) : resolve(stats.isDirectory())\n    })\n  )\n}\n","import fs from 'fs'\n/**\n * @description 建创目录(单层)\n * @param {String} fFolder 要创建的目录\n * @returns {Promise<Boolean>}\n */\nexport const FFHandleMakeFolderOne = (fFolder:string) => {\n  return new Promise(resolve => fs.mkdir(fFolder, err => {\n    err ? resolve(false) : resolve(true)\n  }))\n}\n","import fs from 'fs'\nimport { ensureFootHave } from '../../src'\n\n/**\n * @description 将数据保存成文件\n * @param {*} fData 文件数据\n * @param {String} fFile 文件名\n * @param {String} [fFolder] 目录\n * @returns {Promise<String>}\n */\nexport const FFHandleDataSaveFile = (fData:any, fFile:string, fFolder:string) => {\n  const fullPath = `${fFolder ? ensureFootHave(fFolder, '/') : ''}${fFile}`\n  return new Promise(resolve => fs.writeFile(fullPath, fData, err => err ? resolve('') : resolve(fullPath)))\n}\n","import fs from 'fs'\nimport { ensureFootHave } from '../../src'\n/**\n * @description 删除文件\n * @param {String} fFile 要删除的文件\n * @param {String} [fFilePath] 文件所在的路径\n * @returns {Promise<Boolean>}\n */\nexport const FFHandleDeleteFile = (fFile:string, fFilePath:string) => {\n  const fullPath = `${fFilePath ? ensureFootHave(fFilePath, '/') : ''}${fFile}`\n  return new Promise(resolve => fs.unlink(fullPath, err => err ? resolve(false) : resolve(true)))\n}\n","import fs from 'fs'\nimport { ensureFootHave } from '../../src'\n\n/**\n * @description 删除文件\n * @param {String} fFile 要删除的文件\n * @param {String} [fFolder] 文件所在的路径\n */\nexport const FFHandleDeleteFileSync = (fFile:string, fFolder:string) => {\n  if (fFile) {\n    const fullPath = `${fFolder ? ensureFootHave(fFolder, '/') : ''}${fFile}`\n    if (fs.existsSync(fullPath)) {\n      fs.unlinkSync(fullPath)\n      console.log(`文件删除成功：${fullPath}`)\n    }\n  }\n}\n","import fs from 'fs'\n\n/**\n * @description 删除文件夹\n * @param fFolder 目录\n * @returns {Promise<Boolean>}\n */\nexport const FFHandleDeleteFolder = (fFolder: string) => new Promise(resolve => fs.rmdir(\n  fFolder,\n  {\n    recursive: true\n  },\n  err => err ? resolve(false) : resolve(true)\n))\n","import fs from 'fs'\n\n/**\n * @description 获取目录或文件的系统明细\n * @param {String} fOrFPath 要查看的目录或文件路径\n * @constructor\n */\nexport const FFHandleIsFile = (fOrFPath: string) => {\n  return new Promise(resolve => fs.stat(\n    fOrFPath,\n    (err, stats) => {\n      err ? resolve(false) : resolve(stats.isFile())\n    })\n  )\n}\n","import path from 'path'\nimport {FFHandleIsExists} from './FFHandleIsExists'\nimport { FFHandleIsFolder } from './FFHandleIsFolder'\nimport { FFHandleMakeFolderOne } from './FFHandleMakeFolderOne'\n/**\n * @description 建创目录(多层)\n * @param {String} fFolder 目录字符串\n * @return {*}\n */\nexport const FFHandleMakeFolderPath = async (fFolder:string) => {\n  const isExists = await FFHandleIsExists(fFolder)\n  const isFolder = await FFHandleIsFolder(fFolder)\n  if (isExists && isFolder) { // 如果该路径存在且不是文件，返回 true\n    return true\n  } else if (isExists) { // 路径存在，但是是文件，返回 false\n    return false\n  } else { // 如果该路径不存在\n    const tempDir = path.parse(fFolder).dir\n    const status = await FFHandleMakeFolderOne(tempDir) // 循环遍历，递归判断如果上级目录不存在，则产生上级目录\n    if (status) {\n      return await FFHandleMakeFolderOne(fFolder)\n    } else {\n      return false\n    }\n  }\n}\n","import fs from 'fs'\n/**\n * @description 目录下所有的文件(不包含文件夹)\n * @param {String} folder 目录\n * @returns {Promise<Array>}\n */\nexport const FFHandleReadFolderDF = (folder:string) => {\n  return new Promise(resolve => fs.readdir(\n    folder,\n    (err, files) => err ? resolve([]) : resolve(files)\n  ))\n}\n","import fs from 'fs'\n\n/**\n * @description 目录下所有的文件(不包含文件夹)\n * @param {String} fFolder 目录\n * @returns {Array}\n */\nexport const FFHandleReadFolderDFSync = (fFolder:string) => {\n  const files: any[] = []\n  fs.readdirSync(fFolder).forEach((name) => {\n    files.push(`${name}`)\n  })\n  return files\n}\n"],"names":["ensureFootHave","ensureString","ensureAssign","theString","String","theAssign","substr","length","fs","require","FFHandleIsExists","fOrFPath","Promise","resolve","existsSync","FFHandleIsFolder","stat","err","stats","isDirectory","FFHandleMakeFolderOne","fFolder","mkdir","fData","fFile","fullPath","writeFile","fFilePath","unlink","unlinkSync","console","log","rmdir","recursive","constructor","aFile","this","parseFile","file","destination","des","filename","originalname","path","suffix","split","filePath","newFile","parse","reject","renameSync","Error","isFile","__awaiter","isExists","isFolder","tempDir","dir","folder","readdir","files","readdirSync","forEach","name","push"],"mappings":"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"}