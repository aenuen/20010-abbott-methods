{"version":3,"file":"import.js","sources":["../src/ensure/ensureFootHave.ts","../nodeTs/FFHandle/FFHandleDataSaveFile.ts","../nodeTs/FFHandle/FFHandleDeleteFile.ts","../nodeTs/FFHandle/FFHandleDeleteFileSync.ts","../nodeTs/FFHandle/FFHandleDeleteFolder.ts","../nodeTs/FFHandle/FFHandleFileParse.ts","../nodeTs/FFHandle/FFHandleGetStats.ts","../nodeTs/FFHandle/FFHandleMakeFolderOne.ts","../nodeTs/FFHandle/FFHandleMakeFolderPath.ts","../nodeTs/FFHandle/FFHandleReadFolderDF.ts","../nodeTs/FFHandle/FFHandleReadFolderDFSync.ts"],"sourcesContent":["/**\n * @desc 保证字符串尾部含有指定字符\n * @param {number|string} ensureString\n * @param {number|string} ensureAssign\n * @returns {number|string}\n */\nexport const ensureFootHave = (ensureString: number | string, ensureAssign: number | string): string => {\n  const theString = String(ensureString)\n  const theAssign = String(ensureAssign)\n  return theString.substr(-theString.length) === theAssign ? theString : theString + theAssign\n}\n","import fs from 'fs'\nimport { ensureFootHave } from '../../src'\n\n/**\n * @description 将数据保存成文件\n * @param {*} fData 文件数据\n * @param {String} fFile 文件名\n * @param {String} [fFolder] 目录\n * @returns {Promise<String>}\n */\nexport const FFHandleDataSaveFile = (fData:any, fFile:string, fFolder:string) => {\n  const fullPath = `${fFolder ? ensureFootHave(fFolder, '/') : ''}${fFile}`\n  return new Promise(resolve => fs.writeFile(fullPath, fData, err => err ? resolve('') : resolve(fullPath)))\n}\n","import fs from 'fs'\nimport { ensureFootHave } from '../../src'\n/**\n * @description 删除文件\n * @param {String} fFile 要删除的文件\n * @param {String} [fFilePath] 文件所在的路径\n * @returns {Promise<Boolean>}\n */\nexport const FFHandleDeleteFile = (fFile:string, fFilePath:string) => {\n  const fullPath = `${fFilePath ? ensureFootHave(fFilePath, '/') : ''}${fFile}`\n  return new Promise(resolve => fs.unlink(fullPath, err => err ? resolve(false) : resolve(true)))\n}\n","import fs from 'fs'\nimport { ensureFootHave } from '../../src'\n\n/**\n * @description 删除文件\n * @param {String} fFile 要删除的文件\n * @param {String} [fFolder] 文件所在的路径\n */\nexport const FFHandleDeleteFileSync = (fFile:string, fFolder:string) => {\n  if (fFile) {\n    const fullPath = `${fFolder ? ensureFootHave(fFolder, '/') : ''}${fFile}`\n    if (fs.existsSync(fullPath)) {\n      fs.unlinkSync(fullPath)\n      console.log(`文件删除成功：${fullPath}`)\n    }\n  }\n}\n","import fs from 'fs'\n\n/**\n * @description 删除文件夹\n * @param fFolder 目录\n * @returns {Promise<Boolean>}\n */\nexport const FFHandleDeleteFolder = (fFolder: string) => new Promise(resolve => fs.rmdir(\n  fFolder,\n  {\n    recursive: true\n  },\n  err => err ? resolve(false) : resolve(true)\n))\n","const fs = require('fs')\n\nexport class FFHandleFileParse {\n  // 预先处理\n  private suffix: string | undefined;\n  private path: string | undefined;\n  private filePath: string | undefined;\n  private newFile: string | undefined;\n  private originalname: string | undefined;\n\n  constructor(aFile: any) {\n    this.parseFile(aFile)\n  }\n\n  // 解析文件\n  parseFile(file: Record<string | number | symbol, any>) {\n    const {destination: des, filename = '', originalname = '', path = ''} = file\n    const suffix = originalname.split('.')[1] || ''\n    this.suffix = suffix\n    this.path = path\n    this.filePath = `${des}${filename}.${suffix}`\n    this.newFile = `${filename}.${suffix}`\n    this.originalname = <string>originalname\n  }\n\n  // 解析\n  parse() {\n    return new Promise((resolve, reject) => {\n      if (this.suffix) {\n        if (fs.existsSync(this.path) && !fs.existsSync(this.filePath)) {\n          fs.renameSync(this.path, this.filePath)\n        }\n        resolve(this)\n      } else {\n        reject(new Error('上文件的后缀名无效'))\n      }\n    })\n  }\n}\n","import fs from 'fs'\n\n/**\n * @description 获取目录或文件的系统明细\n * @param {String} fOrFPath 要查看的目录或文件路径\n * @constructor\n */\nexport const FFHandleGetStats = (fOrFPath: string):Record<string | number | symbol, any> => {\n  return new Promise(resolve => fs.stat(\n    fOrFPath,\n    (err, stats) => {\n      err ? resolve({}) : resolve(stats)\n    })\n  )\n}\n","import fs from 'fs'\n/**\n * @description 建创目录(单层)\n * @param {String} fFolder 要创建的目录\n * @returns {Promise<Boolean>}\n */\nexport const FFHandleMakeFolderOne = (fFolder:string) => {\n  return new Promise(resolve => fs.mkdir(fFolder, err => {\n    err ? resolve(false) : resolve(true)\n  }))\n}\n","import path from 'path'\nimport { FFHandleGetStats } from './FFHandleGetStats'\nimport { FFHandleMakeFolderOne } from './FFHandleMakeFolderOne'\n/**\n * @description 建创目录(多层)\n * @param {String} fFolder 目录字符串\n * @return {*}\n */\nexport const FFHandleMakeFolderPath = async (fFolder:string) => {\n  const isExists = await FFHandleGetStats(fFolder)\n  if (isExists && isExists.isDirectory()) { // 如果该路径存在且不是文件，返回 true\n    return true\n  } else if (isExists) { // 路径存在，但是是文件，返回 false\n    return false\n  } else { // 如果该路径不存在\n    const tempDir = path.parse(fFolder).dir\n    const status = await FFHandleMakeFolderPath(tempDir) // 循环遍历，递归判断如果上级目录不存在，则产生上级目录\n    if (status) {\n      return await FFHandleMakeFolderOne(fFolder)\n    } else {\n      return false\n    }\n  }\n}\n","import fs from 'fs'\n/**\n * @description 目录下所有的文件(不包含文件夹)\n * @param {String} folder 目录\n * @returns {Promise<Array>}\n */\nexport const FFHandleReadFolderDF = (folder:string) => {\n  return new Promise(resolve => fs.readdir(\n    folder,\n    (err, files) => err ? resolve([]) : resolve(files)\n  ))\n}\n","import fs from 'fs'\n\n/**\n * @description 目录下所有的文件(不包含文件夹)\n * @param {String} fFolder 目录\n * @returns {Array}\n */\nexport const FFHandleReadFolderDFSync = (fFolder:string) => {\n  const files: any[] = []\n  fs.readdirSync(fFolder).forEach((name) => {\n    files.push(`${name}`)\n  })\n  return files\n}\n"],"names":["ensureFootHave","ensureString","ensureAssign","theString","String","theAssign","substr","length","FFHandleDataSaveFile","fData","fFile","fFolder","fullPath","Promise","resolve","fs","writeFile","err","FFHandleDeleteFile","fFilePath","unlink","FFHandleDeleteFileSync","existsSync","unlinkSync","console","log","FFHandleDeleteFolder","rmdir","recursive","require","FFHandleFileParse","constructor","aFile","this","parseFile","file","destination","des","filename","originalname","path","suffix","split","filePath","newFile","parse","reject","renameSync","Error","FFHandleGetStats","fOrFPath","stat","stats","FFHandleMakeFolderOne","mkdir","FFHandleMakeFolderPath","__awaiter","isExists","isDirectory","tempDir","dir","FFHandleReadFolderDF","folder","readdir","files","FFHandleReadFolderDFSync","readdirSync","forEach","name","push"],"mappings":"sCAMO,MAAMA,EAAiB,CAACC,EAA+BC,KAC5D,MAAMC,EAAYC,OAAOH,GACnBI,EAAYD,OAAOF,GACzB,OAAOC,EAAUG,QAAQH,EAAUI,UAAYF,EAAYF,EAAYA,EAAYE,GCCxEG,EAAuB,CAACC,EAAWC,EAAcC,KAC5D,MAAMC,EAAW,GAAGD,EAAUX,EAAeW,EAAS,KAAO,KAAKD,IAClE,OAAO,IAAIG,SAAQC,GAAWC,EAAGC,UAAUJ,EAAUH,GAAOQ,GAAaH,EAANG,EAAc,GAAcL,QCJpFM,EAAqB,CAACR,EAAcS,KAC/C,MAAMP,EAAW,GAAGO,EAAYnB,EAAemB,EAAW,KAAO,KAAKT,IACtE,OAAO,IAAIG,SAAQC,GAAWC,EAAGK,OAAOR,GAAUK,GAAaH,GAANG,QCF9CI,EAAyB,CAACX,EAAcC,KACnD,GAAID,EAAO,CACT,MAAME,EAAW,GAAGD,EAAUX,EAAeW,EAAS,KAAO,KAAKD,IAC9DK,EAAGO,WAAWV,KAChBG,EAAGQ,WAAWX,GACdY,QAAQC,IAAI,UAAUb,QCNfc,EAAwBf,GAAoB,IAAIE,SAAQC,GAAWC,EAAGY,MACjFhB,EACA,CACEiB,WAAW,IAEbX,GAAaH,GAANG,OCZHF,EAAKc,QAAQ,YAENC,EAQXC,YAAYC,GACVC,KAAKC,UAAUF,GAIjBE,UAAUC,GACR,MAAOC,YAAaC,EAAGC,SAAEA,EAAW,GAAEC,aAAEA,EAAe,GAAEC,KAAEA,EAAO,IAAML,EAClEM,EAASF,EAAaG,MAAM,KAAK,IAAM,GAC7CT,KAAKQ,OAASA,EACdR,KAAKO,KAAOA,EACZP,KAAKU,SAAW,GAAGN,IAAMC,KAAYG,IACrCR,KAAKW,QAAU,GAAGN,KAAYG,IAC9BR,KAAKM,aAAuBA,EAI9BM,QACE,OAAO,IAAIhC,SAAQ,CAACC,EAASgC,KACvBb,KAAKQ,QACH1B,EAAGO,WAAWW,KAAKO,QAAUzB,EAAGO,WAAWW,KAAKU,WAClD5B,EAAGgC,WAAWd,KAAKO,KAAMP,KAAKU,UAEhC7B,EAAQmB,OAERa,EAAO,IAAIE,MAAM,kBC3BZ,MAAAC,EAAoBC,GACxB,IAAIrC,SAAQC,GAAWC,EAAGoC,KAC/BD,GACA,CAACjC,EAAKmC,KACEtC,EAANG,EAAc,GAAcmC,QCLrBC,EAAyB1C,GAC7B,IAAIE,SAAQC,GAAWC,EAAGuC,MAAM3C,GAASM,IACxCH,GAANG;;;;;;;;;;;;;;;qSCAS,MAAAsC,EAAgC5C,GAAkB6C,OAAA,OAAA,OAAA,GAAA,YAC7D,MAAMC,QAAiBR,EAAiBtC,GACxC,GAAI8C,GAAYA,EAASC,cACvB,OAAO,EACF,GAAID,EACT,OAAO,EACF,CACL,MAAME,EAAUnB,EAAKK,MAAMlC,GAASiD,IAEpC,eADqBL,EAAuBI,YAE7BN,EAAsB1C,QCZ5BkD,EAAwBC,GAC5B,IAAIjD,SAAQC,GAAWC,EAAGgD,QAC/BD,GACA,CAAC7C,EAAK+C,IAAgBlD,EAANG,EAAc,GAAc+C,OCFnCC,EAA4BtD,IACvC,MAAMqD,EAAe,GAIrB,OAHAjD,EAAGmD,YAAYvD,GAASwD,SAASC,IAC/BJ,EAAMK,KAAK,GAAGD,QAETJ"}